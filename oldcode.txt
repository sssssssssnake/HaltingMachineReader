
>>> Main.f95 d1dc10cfdb104dbc36ae3cbe7fd01da2c60469f6

subroutine readFile(filePath, fileContents)
    character(:), allocatable, intent(in) :: filePath
    character(:), allocatable, intent(out) :: fileContents
    integer :: iostat, unitNumber, i, fileSize
    character(100) :: testChar

    ! Use a named constant for the unit number
    unitNumber = 10

    ! Open the file and get its size
    open(unitNumber, file=filePath, status="old", iostat=iostat)
    if ( iostat /= 0 ) then
        print *, "Error opening file"
        stop
    end if

    ! Get the file size
    inquire(unitNumber, size=fileSize) 

    ! Allocate the fileContents variable
    allocate(character(fileSize) :: fileContents)
    print *, "File size: ", fileSize
    print *, "File contents length: ", len(fileContents)


    print *, "Reading file"
    print *, "error status: ", iostat

    ! Read the file 
    ! turns out read literally reads line by line and the rewind function is needed to read the file again
    read(unitNumber, '(A)', iostat=iostat) fileContents
    read(unitNumber, '(A)', iostat=iostat) testChar
    print *, "error status: ", iostat
    print *, "testChar: ", testChar
  

end subroutine readFile

<<<


>>> readfile.f95 9942c7e938d5ea920a51d180607c319baddd2fe2
program read_file
    implicit none
    character(len=100) :: line
    integer :: iounit, iostat

    ! Open the file
    open(newunit=iounit, file='main.f95', status='old', action='read', iostat=iostat)
    if (iostat /= 0) then
        print *, 'Error opening file!'
        stop
    end if

    ! Read the file line by line
    do
        read(iounit, '(A)', iostat=iostat) line
        if (iostat /= 0) exit  ! Exit loop on end of file or error
        print *, trim(line)
    end do

    ! Close the file
    close(iounit)
end program read_file

<<<